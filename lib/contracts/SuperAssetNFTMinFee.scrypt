/**
Copyright (c) 2022 Matter Web Services Inc., Attila Aros 
 
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
 
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

Addtionally, the ASM Versions are included in this copyright:

A)
<assetId (36 bytes)> <pkh 20 bytes>  
 

*/

// SuperAssetNFTMinerFee
//
// Non-Fungible-Token (NFT) Smart Contract for Bitcoin.
// ----------------------------------------------------------------------------------------------
//
// Key Features of SuperAssetNFT:
//     - Mint, transfer, update, and transform(melt) NFTs.
//     - Supports seperate funding inputs and change outputs with ANYONECANPAY
//     - Store arbitrary data payloads (HTML, JSON, Protobuf, PDFs, images, XML, etc)
//     - Replay protection with globally unique ID passed on as an 'identity baton'
//     - Can destroy or transform the token via "transform(melt)" and retrieve the satoshis
//     - Identical trust guarantees as a regular UTXO
//     - Developers can easily verify authenticity and asset history by requesting it in it's entirety from the seller
//     - Wallets and indexers can proactively index these UTXO's via a blind pattern match for the minting pattern
//     - Simplfied Payment Verification (SPV) and 0-conf works as expected with all the properties afforded to the native satoshi
//     - Use of SIGHASH_SINGLE allows token to be composable with other smart contracts
//     - Polymorphism is made possible because the data state (assetID and ownerAddress) appears at the beginning of the contract layout
//     - Small footprint of 242 bytes (release) or 252 bytes (debug)
//
//  Contract Code and State Layout:
//  ============================================================================
//                       
//  assetID(36B) ownerAddress(20B) | SuperAssetNFT STATIC CODE
//                       
//  ============================================================================
//
// Example Deploy Transaction: https://www.whatsonchain.com/tx/x
// Example Mint Transaction: https://www.whatsonchain.com/tx/876e5586998bf53893441027882da44eae0aeb5506153d245a8e0813f7262672
// Example Transfer Transaction: https://www.whatsonchain.com/tx/85afa621a98404e3478d3013ca827e30a867cd3ed5b5782b05f80c70879f9e48
// Example Melt Transaction:Â https://www.whatsonchain.com/tx/a9c86b7d9bc91694345cc286f282c25ee3484a9d7d073c0aae1d81c603387ca0
contract SuperAssetNFTMinFee {

    // Do NOT provide a constructor as that will add unnecessary OP_0 OP_0 to the beginning of the contract
    bytes assetid;          // Assetid is the first push data
    Ripemd160 pubKeyHash;   // Current owner is the second push data
    bytes nameOutputHash160;// Hash160 of the name NFT allowed
    bytes feeOutputHash160; // Hash160 of a required output, note that you must use SIGHASH_ALL to use this contract

    /**
    * There is a single method 'unlock' that can be used to transition to token into any state.
    * 
    * @param txPreimage - Preimage used for reflection of the currrent transaction
    * @param outputSatsWithSize - The bytes of the satoshis to transfer along with the output varInt (ex: f2) to indicate the length of the script. Plus '24' at the end.
    * @param receiveAddressWithSize - Leading '14' with the hash160 to send the token to
    * @param isTransform - Whether to transform or morph the transaction into anything else. Care must be taken to preseve the assetid as the first push data
    * @param senderSig - The signature of the previous owner to authorize this update
    * @param unlockKey - The public key that belonged to the previous owner that is beng used to unlock
    * @param feeNFT - The NFT script of the miner fee token
    */
    public function unlock(SigHashPreimage txPreimage, bytes outputSatsWithSize, bytes receiveAddressWithSize, Sig senderSig, PubKey unlockKey, bytes nameNFT, bytes feeBurner) {
        // Modify this contract to your needs but ensure that the resulting contract produces <assetid> <pkh> as the first two push datas
        // But following the convention that <assetid> <pkh> are the first two push datas then we have "polymorphism"
        // For example we can transform (using isTransform=true) to an auction script, and then transform back when there is a winning bid
        require(hash160(unlockKey) == this.pubKeyHash);
        require(checkSig(senderSig, unlockKey));
        require(this.nameOutputHash160 == ripemd160(nameNFT));
        require(this.feeOutputHash160 == ripemd160(feeBurner));
        // This is highly optimized for reduction in size
        require(
            hash256(
                // Include the bytes satoshis, and the script varInt byte size
                outputSatsWithSize +
                // Notice that this.assetid is a member variable and we do not check the locking script in the preimage
                // The reason we do not need to check the locking script is that this.assetid is the first push data
                // The compiler will reference the bottom 
                (this.assetid == num2bin(0, 36) ? txPreimage[ 68 : 104 ] : this.assetid) +
                receiveAddressWithSize + 
                nameNFT +
                feeBurner
            ) 
            ==
            txPreimage[len(txPreimage) - 40 : len(txPreimage) - 8] 
        );   
 
        require(Tx.checkPreimageOpt_(txPreimage));
    }
}
